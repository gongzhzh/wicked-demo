@AssumptionBuster I’m keeping both panels visible, switching users (admin and normal user) around and do cancel then flip filters and sort to see if reservation state leaks. What invariants should I check to confirm whether any stale state is persisting and how can I avoid false alarms?

Good scope — you’re already exercising the likely leak-path (two visible panels + role switches + UI transforms). Below I give a compact checklist of concrete invariants to assert, practical test steps (so you can reproduce reliably), tips to avoid false positives, an exploratory (divergent) test angle to try, and an adversarial challenge you can use to sharpen the test.

Key requirements to ground these checks

The “My Reservations” panel must show only reservations for the active User ID and must refresh when the active user changes .
Filters/sorts are view-only (must not modify underlying data) and must produce deterministic results for the same parameters .
When a cancellation is accepted the reservation is removed, the class remaining slots increase by 1, and both panels refresh to reflect the change .
The app is single-page and runs in-memory (so state lives client-side; a page reload resets data) — use that to your advantage for clean setup/teardown .
Invariants to check (things that must always be true)

User-scoped reservation invariants

My Reservations contains exactly the set of reservations with userId == activeUserId. No reservation for a previous user should be visible after Set User / Role. (FR-26)
The Cancel action only affects reservations that belong to the active user; cancel should be disabled or rejected for other users (BR-8)
Capacity / class state invariants

After a successful cancel: class.remainingSlots increases by 1 and class.status is recalculated (e.g., Full→Available) and reflected in Available Classes. (FR-31, FR-24)
remainingSlots never becomes negative (NFR-7)
View consistency invariants

Changing filters or sort re-applies both and does not mutate reservation data (BR-12, BR-13). The view must be consistent with the active filter+sort parameters (FR-20/21)
Admin panel visibility strictly follows role (only visible when admin authenticated) (BR-14)
Timing / refresh invariants

UI updates (reserve/cancel/filter/sort/admin edits) must complete within the expected delay (the spec expects quick updates), so tests should allow for brief update windows rather than immediately failing (NFR-4)
Concrete test steps (minimal, repeatable scenario)

Setup
Start with a clean in-memory state (reload page). Use unique test User IDs (userA, userB) and known test class IDs where capacity is > 0.
Baseline capture
As userA: reserve class X. Record: MyReservations list, AvailableClasses.remainingSlots for X, status badge.
Switch role
Set User → userB (regular). Assert MyReservations shows only userB reservations (empty unless you create one), and that class X.remainingSlots has the decremented value visible in AvailableClasses. (FR-26, FR-24)
Reproduce the candidate leak
While both panels visible, do: cancel (as userA) — for the bug you described you may need to simulate switching back and forth: a) Immediately flip filters (change type/instructor) and sort (asc/desc) after pressing Cancel, or b) Change the active user to admin and back, then reapply filters/sort.
After UI settles, assert: MyReservations for active user contains the correct set; remainingSlots for class X equals baseline +1 if the cancel succeeded.
Cross-checks (to reduce false positives)
Check the in-memory model (if you have access to a JS console hook) or API of the SPA rather than only DOM text. The persistent model should match the UI.
Reload the page: page reload must reflect the in-memory reset behaviour (if you re-created state intentionally, re-run setup) — because data is client-only C-1/C-2, reload is a deterministic reset to clear transient caches
What to capture/assert (evidence)

Before/after screenshots of both panels, plus a small JSON snapshot of the in-memory reservations and class objects (class id, remainingSlots, reservation.userId, reservation.id).
Timestamps of actions and time spent between action and UI change (to tolerate the allowed UI update latency). NFR says interactions should complete quickly — allow a small wait (e.g., up to 1s) before failing .
Console logs or application state dumps (if available) showing the removal of the reservation and the slot increment.
How to avoid false alarms

Deterministic test data: use unique User IDs and classes so you can identify cross-user leaks (no “shared” names).
Wait for the UI to finish updating: the spec expects quick responses but not instantaneous — use an explicit wait or poll for the invariants up to a small timeout (e.g., 1s) rather than asserting immediately (NFR-4) .
Compare model vs view: prefer asserting the app’s in-memory model or data structures when possible (less flaky than text scraping). Because this app is client-only, you can often access the model in the console or add a debug hook for tests (C-1/C-2) .
Reset filters/sorts before a new scenario unless you’re explicitly testing filter persistence (FR-17 says filters maintain state until changed) — that avoids confusion where a reservation is hidden by filters, not leaked .
Separate functional failures from UI rendering artifacts: e.g., if a reservation is removed in the model but the DOM lingers for a render frame, that’s a UI-timing artifact, not a data leak.
Edge/race conditions to try (these are common leak triggers)

Cancel, then immediately change active user and flip filters/sort before the cancel promise resolves. Look for inconsistent state once async updates complete.
Admin edits class capacity/status while a normal user is viewing and with filters applied. Edits should propagate to both panels (FR-39) .
Rapidly toggle sort/filter repeatedly after cancel to see stale rendering under rapid reflows (tests for idempotence/determinism of filtering/sort BR-11/BR-13) .
Divergent exploratory question (reframe / new angle)

Instead of switching the single active user, what if you simulated two independent views (e.g., two browser windows: one logged in as admin, one as a normal user) and performed cancel/reserve/sort/filter actions concurrently? Would the in-memory-only design cause conflicting local state or apparent leaks when you swap focus between windows? (This diverges from your single-page single-view approach and may reveal assumptions about single-session state.)
Adversarial feedback / challenge (push back on assumptions)

Counterpoints to the hypothesis “visible panel + flip filters → leak”: it could be (a) a rendering/timing artifact where the model was updated but the DOM wasn’t yet re-rendered, (b) filters hiding/showing elements making it look like state moved, or (c) admin UI elements revealing data that are actually correct for admin (not a leak). Can you show model-level evidence (not just screenshots) that the reservation object still exists after cancel? If not, prioritize capturing the app’s internal data snapshot as evidence.
Please justify: why do you assume the leak occurs only when both panels are visible? Could hidden-panel behaviour differ (e.g., stale virtual DOM nodes) — test both visible and hidden to be sure.
If you want, I can:

produce a compact test script (step-by-step) you can paste into a test runner (Puppeteer / Playwright) that checks the invariants and captures model snapshots; or
suggest exact assertions and wait strategies (polling interval + timeout) for your automation.
Which would you prefer — a manual checklist you can copy into your test case management system, or an executable Playwright/Puppeteer skeleton that implements these checks?
