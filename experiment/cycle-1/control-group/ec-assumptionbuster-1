@AssumptionBuster I’m keeping both panels visible, switching users (admin and normal user) around and do cancel then flip filters and sort to see if reservation state leaks. What invariants should I check to confirm whether any stale state is persisting and how can I avoid false alarms?

Good — you’re already exercising a rich scenario. Below is a compact checklist of invariants to assert (what must always be true), concrete checks you can run after each action, and practical tips to avoid false alarms. I’ll finish with a divergent test idea and an adversarial challenge to your assumptions.

Key source requirements to keep in mind while testing:

The “My Reservations” panel must show only reservations for the active User ID and must refresh when the active user changes, when reservations are created/cancelled, or when class details change .
Filters/search/ sort affect only the view (not underlying data) and sorting/filtering are deterministic; changing them must reapply both filter and sort to produce a consistent list .
Cancellations must remove the reservation, increase remaining slots, update status badges, and refresh both panels .
Filters/search state persists until explicitly changed; sort respects current filters/search .
Client-side, in-memory app: page refresh resets all data; UI updates should complete within ~1s (so allow for short delays) .
Invariants to assert (check these after each step in your scenario)

User-scoped invariants
MyReservations contains only reservations whose reservation.userId == activeUserId. Verify every reservation card’s user association or ID tag. Requirement: FR-26 .
When you switch active user, MyReservations is replaced with that user’s reservations (no remnants from previous user).
2. Cancellation invariants

After a successful cancel: reservation is removed from MyReservations, the class.remainingSlots increases by 1, and class status recalculated (e.g., Full → Available). Requirement: FR-31 and FR-24 .
Cancellation must be rejected for past classes or within 1 hour (if rejection occurs, UI shows an explicit error and nothing changes) .
3. View/filter/sort invariants

Filters and search do not mutate underlying reservation/class data: they only affect what’s shown (BR-12) .
After you flip filters or change sort order, the visible lists must match what you would compute by applying the same filter+sort to the canonical dataset (deterministic ordering required) .
If a cancellation made a class become Available, it must appear in “Available Classes” according to current filters/sort rules (FR-20/FR-21) .
4. Data consistency invariants

remainingSlots must never go negative and must equal capacity − count(reservations for that class) at all times (NFR-7, FR-24) .
Business rules like max 3 future reservations, no double-booking, etc., must hold after any operation (BR-3, BR-4) .
Concrete checks / test steps (minimal reproducible sequence)

Baseline snapshot
Capture: activeUserId, MyReservations list (IDs+classIDs+timestamps), AvailableClasses list (IDs, remainingSlots, status badges), current filters and sort settings, UI message area text.
2. Perform the action sequence you described:

Keep both panels visible.
Set user = alice (regular), create/confirm a reservation X for class A.
Set user = bob (admin or normal) — observe MyReservations updates (should not show X).
As bob, perform a Cancel (or if you mean cancel while switching, follow your exact flow).
Immediately flip filters and change sort.
3. Post-action snapshot

Re-capture the same fields as baseline.
4. Assertions

Reservation X no longer appears in any MyReservations (unless the active user is the owner and cancellation was rejected for legitimate rule).
Class A.remainingSlots increased by 1 and status badge updated if needed.
AvailableClasses list post-filter/sort is exactly the deterministic sorted/filtered view of the canonical dataset.
No reservations from the previously active user remain visible when activeUserId is different.
UI message area shows the success or rejection message for the cancel action.
How to avoid false alarms (common pitfalls and mitigations)

Timing: UI updates are expected to be fast but may take up to NFR-4’s 1s. Wait a small grace interval (e.g., 1–1.5s) before asserting. The app is in-memory (no backend), so transient network latency is not a factor, but rendering or event-loop scheduling may delay updates .
Filters hiding results: a reservation may be “missing” because current filters hide its class. When you see a missing item, first clear filters/search and re-check.
Deterministic sort: compare canonical sets (IDs) rather than visual index positions to avoid false positives from sort-order changes; requirement guarantees deterministic ordering for same parameters .
Cancellation failure vs. stale UI: if cancel is rejected by business rules, the UI should show a rejection message — treat that as expected behavior, not a leak. Check the message area and console for error messages .
State reset on page reload: remember that a full page refresh resets all data (so don’t mix refreshes into the same test session) .
Automation tips (if you automate checks)

Compare canonical object IDs and numeric counts rather than rendered text.
Read in-memory data structures (if available via devtools or exposed test hooks) and assert invariants there; this avoids rendering/flakiness.
If you must compare the DOM, normalize timestamps and strip transient message text before comparison.
Use explicit waits for the “success” message or for a stable DOM snapshot (instead of blind timeouts).
Divergent (reframing) suggestion — try the opposite hypothesis

Instead of assuming the stale state is caused by the view not refreshing, assume it’s caused by shared mutable data (global variables or event listeners) that incorrectly map reservations to the wrong user. Test this by creating two reservations for different users with easily distinguishable IDs, then switch roles rapidly and check whether the class.remainingSlots and reservation.userId mapping ever diverge. Also try running the exact sequence in two separate browser windows (same page) to see if cross-window/global leakage occurs.
Adversarial feedback — challenge your current view

Counterarguments to “it’s a stale-state leak”:
The UI might be intentionally hiding results due to active filters (not leaking state).
The cancellation could have been rejected by a business rule (e.g., too late), so no state change should occur.
You may be observing a rendering delay rather than stale memory; waiting briefly or checking the in-memory model can disambiguate.
Quick questions to justify the leak hypothesis:
What exact symptom makes you call it a “leak”? (e.g., wrong reservation owner shown, remainingSlots not matching count, or duplicate reservation)
Do you see success/failure messages in the message area when you cancel?
Do console errors appear when switching users or manipulating filters? Answering these will help narrow whether you need to chase a UI-render bug, a business-rule rejection, or a true memory leak/state-misassociation.
If you want, I can:

Produce a short, automated test script (pseudo-code) that performs your exact sequence and asserts the invariants above, or
Help you design a minimal repro (data setup + steps + expected vs actual) so you can file a clear bug report.
Which do you prefer?
