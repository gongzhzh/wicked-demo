
@AssumptionBuster I’m keeping both panels visible, switching users (admin and normal user) around and do cancel then flip filters and sort to see if reservation state leaks. What invariants should I check to confirm whether any stale state is persisting and how can I avoid false alarms?

Nice approach — keeping both panels visible and exercising user switches + cancels + filter/sort is exactly the kind of interaction that exposes UI-state leakage. A few targeted invariants will quickly tell you whether state is stale, and simple precondition checks will cut down on false positives.

Key requirements to keep in mind as your ground-truth: filters/sort must only affect view, not data (BR‑12/BR‑13) and the UI must refresh when the active user changes (FR‑21/FR‑28) . Use those as the oracle when you see “odd” behavior.

Invariants to check (what to assert each time you run the scenario)

Ownership invariant (single-source of truth for reservations)
Assert: “My Reservations” shows only reservations whose reservation.userId == activeUserId. Requirement FR‑26 describes this association .
Test action: switch to user A → record reservations list; switch to user B → ensure A’s reservations disappear; switch back → A’s reservations reappear exactly as before (unless you performed a mutation).
Capacity conservation (accounting invariant)
Assert: for each class: capacity == remainingSlots + numberOfActiveReservationsForThatClass (or capacity - remainingSlots == total reservations for that class). FR‑24/FR‑31 describe remaining slots changes on create/cancel and refresh effects .
Test action: note remainingSlots and reservation counts, cancel a reservation as user who owns it, then verify remainingSlots increments and the counts reconcile.
Cancel / mutation atomicity
Assert: after a successful cancel, reservation is removed from My Reservations and remainingSlots + status badges update in Available Classes; and message area shows success. FR‑31 and UI message requirement reference these updates fileciteturn0file5turn0file0.
Test action: cancel while filters hide that class in Available Classes — verify the change is still applied to the underlying data (see next bullet).
View-vs-data separation (filters/sort are view-only)
Assert: changing filters or sort does not change underlying reservation data or capacities (BR‑12); sorting/filtering only changes what is shown (BR‑11/BR‑13) .
Test action: set a filter so a reserved class is hidden in Available Classes, cancel the reservation from My Reservations, then remove filters and verify capacity/status reflect the cancel.
Determinism of sort/filtered order
Assert: for a fixed data set + fixed filter/sort parameters, the displayed order is deterministic (BR‑13/FR‑19/FR‑20) fileciteturn0file2turn0file4.
Test action: repeatedly toggle the same sort/filter combo and confirm order is stable.
Permission visibility invariant
Assert: Admin Panel and admin-only controls are visible only when an admin is active (PM‑1/FR‑33), and admin actions still respect reservation rules when they act as users fileciteturn0file1turn0file3.
Test action: switch between admin and regular user and verify the Admin Panel appears/disappears and no admin-only control is accessible to regular users.
Time-related badges & cancel rules
Assert: status badges (Past / Starting Soon / Upcoming) and cancellation availability follow the time-based rules (BR‑6..BR‑10) .
Test action: use classes whose times are well outside the 1‑hour boundary and also test close-to-1‑hour cases deliberately (see false-alarm guidance).
Checks to avoid false alarms (practical heuristics)

Always verify the active-user label before asserting ownership: FR‑1/FR‑3 requires the UI to show the current user/role — double-check that label matches the user you think you set; otherwise you’re testing the wrong actor .
Compare against an unfiltered baseline: if you suspect a leak when a filter is active, reset filters (or capture an “all” view) and recheck invariants; a hidden item is not a leak — it’s a filter doing its job (BR‑12/FR‑17) .
Control time or avoid boundary timings: many behaviors are time-dependent (status badges, cancel windows). Use class times far from “starting soon” unless you’re explicitly testing those rules; this reduces flaky failures from slight clock differences (BR‑9, BR‑6..BR‑7) .
Use deterministic test data and repeatable sequences: run the same sequence twice (switch A→B→A, cancel, flip filter/sort repeatedly) to distinguish race conditions from deterministic logic (BR‑13/FR‑19) fileciteturn0file2turn0file4.
Check both UI and underlying aggregates: if possible, expose/inspect any in-memory data structures (or add a debug dump) to confirm the UI matches the model. The system is client-only / in-memory (C‑1/C‑2), so the “truth” is local and inspectable fileciteturn0file1turn0file6.
Watch for UI caching/reuse of DOM nodes: when panels are kept visible, the view layer may reuse DOM elements. If a node is reused, compare element IDs/keys (or text content) rather than relying only on visual position.
Make sure asynchronous updates have completed: if the app updates in <1s per NFR‑4, wait that interval (or wait for the success message) before flipping filters/sort to avoid transient states being mistaken for leaks .
Quick checklist you can run each scenario (short, actionable)

Precondition: record activeUserLabel, filters, sort, and a baseline unfiltered list. (FR‑1, FR‑17) fileciteturn0file6turn0file4
Action: perform cancel as user A (or switch users, then cancel).
Immediately assert:
reservation removed from My Reservations for activeUserLabel (FR‑26)
remainingSlots for that class incremented and status badge updated (FR‑24/FR‑31)
Admin panel visibility matches role (if switching) (FR‑33/PM‑1) fileciteturn0file3turn0file1
Flip filters/sort and re-assert the same data-level invariants (capacity reconciliation, reservation ownership).
Remove filters and compare to baseline to confirm no hidden leakage.
Repeat sequence quickly and with small waits to surface timing/race issues.
Cross-domain hint (useful mindset)

Think of capacity/reservation as an accounting ledger: debits (reserve) and credits (cancel) must balance. That conservation law is a strong invariant to catch leaks or lost updates.
Treat filters/sort like a view-layer cache: if something changes under a cached view, either the cache must be invalidated/refreshed or you’ll see stale UI — assert that refresh is triggered on mutation or user-switch (FR‑20/FR‑21) .
If you want, I can:

Give a short table of concrete assertions you can paste into an automated test harness (e.g., “assert reservationList.filter(r => r.user==activeUser).length == displayedRows”), or
Generate a small deterministic scenario (specific class times, capacities, and a step-by-step script) you can run manually or automate.
Which would help you most next?
